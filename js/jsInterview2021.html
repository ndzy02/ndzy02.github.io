<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>2021 面试题 | blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/assets/logo.png">
    <meta name="description" content="ndzy blog">
    <link rel="preload" href="/assets/css/0.styles.071e6781.css" as="style"><link rel="preload" href="/assets/js/app.5730d439.js" as="script"><link rel="preload" href="/assets/js/2.8e0bb991.js" as="script"><link rel="preload" href="/assets/js/12.3ce7e4c0.js" as="script"><link rel="prefetch" href="/assets/js/10.363a4681.js"><link rel="prefetch" href="/assets/js/11.4c41f4b5.js"><link rel="prefetch" href="/assets/js/13.e0e1fd46.js"><link rel="prefetch" href="/assets/js/14.395da584.js"><link rel="prefetch" href="/assets/js/15.5a9e3c80.js"><link rel="prefetch" href="/assets/js/16.3b18ef21.js"><link rel="prefetch" href="/assets/js/3.b82da945.js"><link rel="prefetch" href="/assets/js/4.a0e2170d.js"><link rel="prefetch" href="/assets/js/5.faf851b2.js"><link rel="prefetch" href="/assets/js/6.aa62f660.js"><link rel="prefetch" href="/assets/js/7.4f8884c0.js"><link rel="prefetch" href="/assets/js/8.cc6b49db.js"><link rel="prefetch" href="/assets/js/9.83debef3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.071e6781.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/react/">
          react
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/word/">
          word
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/interview/">
          interview
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/git/">
          git
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/js/" class="router-link-active">
          js
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/js/" aria-current="page" title="js" class="sidebar-link">js</a></li><li><a href="/js/array.html" title="数组" class="sidebar-link">数组</a></li><li><a href="/js/string.html" title="字符串" class="sidebar-link">字符串</a></li><li><a href="/js/jsInterview2021.html" aria-current="page" title="2021 面试题" class="active sidebar-link">2021 面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#原型" title="原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#箭头函数-和-普通函数" title="箭头函数 和 普通函数" class="sidebar-link">箭头函数 和 普通函数</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#改变-this" title="改变 this" class="sidebar-link">改变 this</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#数组遍历方法" title="数组遍历方法" class="sidebar-link">数组遍历方法</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#let-const-var" title="let const var" class="sidebar-link">let const var</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#new" title="new" class="sidebar-link">new</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-生命周期" title="react 生命周期" class="sidebar-link">react 生命周期</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#废除了哪些生命周期-为什么" title="废除了哪些生命周期? 为什么?" class="sidebar-link">废除了哪些生命周期? 为什么?</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-hooks-第三方库" title="react Hooks? 第三方库" class="sidebar-link">react Hooks? 第三方库</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#usememo-usecallback-区别" title="useMemo useCallback 区别" class="sidebar-link">useMemo useCallback 区别</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#网络请求库" title="网络请求库" class="sidebar-link">网络请求库</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#any-unknown-never" title="any unknown never" class="sidebar-link">any unknown never</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#工程化" title="工程化" class="sidebar-link">工程化</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#工具链" title="工具链" class="sidebar-link">工具链</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#为什么使用-mobx" title="为什么使用 mobx" class="sidebar-link">为什么使用 mobx</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#闭包" title="闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#判断变量类型" title="判断变量类型" class="sidebar-link">判断变量类型</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#浏览器资源加载顺序" title="浏览器资源加载顺序" class="sidebar-link">浏览器资源加载顺序</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#怎么提高网页的加载速度" title="怎么提高网页的加载速度" class="sidebar-link">怎么提高网页的加载速度</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#js-怎么遍历对象" title="js 怎么遍历对象" class="sidebar-link">js 怎么遍历对象</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#css-优先级" title="css 优先级" class="sidebar-link">css 优先级</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#css-定位-悬浮右下角" title="css 定位 悬浮右下角" class="sidebar-link">css 定位 悬浮右下角</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#jsonp-以及缺点" title="jsonp 以及缺点" class="sidebar-link">jsonp 以及缺点</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#ajax" title="ajax" class="sidebar-link">ajax</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#jquery-选择器-选择页面所有的-name-hello-的-input-框-并且给所有的-input-框赋值-test" title="jQuery 选择器，选择页面所有的 name=hello 的 input 框，并且给所有的 input 框赋值&quot;test&quot;" class="sidebar-link">jQuery 选择器，选择页面所有的 name=hello 的 input 框，并且给所有的 input 框赋值&quot;test&quot;</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#虚拟-dom" title="虚拟 dom" class="sidebar-link">虚拟 dom</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#js-创建对象" title="js 创建对象" class="sidebar-link">js 创建对象</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#清除浮动" title="清除浮动" class="sidebar-link">清除浮动</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#让一个页面元素看不见" title="让一个页面元素看不见" class="sidebar-link">让一个页面元素看不见</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-router-原理" title="react router 原理" class="sidebar-link">react router 原理</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#盒模型" title="盒模型" class="sidebar-link">盒模型</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#页面性能优化" title="页面性能优化" class="sidebar-link">页面性能优化</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#解决跨越" title="解决跨越" class="sidebar-link">解决跨越</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#如果你接到一个项目如何从头开始的-需求-技术选型-技术环境-依赖哪些组件" title="如果你接到一个项目如何从头开始的(需求，技术选型，技术环境，依赖哪些组件)" class="sidebar-link">如果你接到一个项目如何从头开始的(需求，技术选型，技术环境，依赖哪些组件)</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#js-继承" title="js 继承" class="sidebar-link">js 继承</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#js-作用域有哪些" title="js 作用域有哪些" class="sidebar-link">js 作用域有哪些</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#屏幕适配" title="屏幕适配" class="sidebar-link">屏幕适配</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#http-三次握手-四次挥手" title="http 三次握手 四次挥手" class="sidebar-link">http 三次握手 四次挥手</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#http-状态码" title="http 状态码" class="sidebar-link">http 状态码</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-特点" title="react 特点" class="sidebar-link">react 特点</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#什么是组件化设计模式" title="什么是组件化设计模式" class="sidebar-link">什么是组件化设计模式</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#什么是单向数据流" title="什么是单向数据流" class="sidebar-link">什么是单向数据流</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-的优缺点" title="react 的优缺点" class="sidebar-link">react 的优缺点</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#vue-与-react-两个框架的区别对比" title="VUE 与 React 两个框架的区别对比" class="sidebar-link">VUE 与 React 两个框架的区别对比</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-的工作原理" title="React 的工作原理" class="sidebar-link">React 的工作原理</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#为什么虚拟-dom-会提高性能" title="为什么虚拟 DOM 会提高性能" class="sidebar-link">为什么虚拟 DOM 会提高性能</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#阻止-react-的默认行为" title="阻止 React 的默认行为" class="sidebar-link">阻止 React 的默认行为</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-中-key-作用是什么" title="React 中 key 作用是什么？" class="sidebar-link">React 中 key 作用是什么？</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#react-中-diff-算法" title="React 中 diff 算法" class="sidebar-link">React 中 diff 算法</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#调用-setstate-之后发生了什么" title="调用 setState 之后发生了什么" class="sidebar-link">调用 setState 之后发生了什么</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#为什么建议传递给-setstate-的参数是一个-callback-回调函数-而不是一个对象" title="为什么建议传递给 setState 的参数是一个 callback（回调函数）而不是一个对象" class="sidebar-link">为什么建议传递给 setState 的参数是一个 callback（回调函数）而不是一个对象</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#setstate-第二个参数的作用" title="setState 第二个参数的作用" class="sidebar-link">setState 第二个参数的作用</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#在构造函数中-调用-super-props-的目的是什么" title="(在构造函数中)调用 super(props) 的目的是什么" class="sidebar-link">(在构造函数中)调用 super(props) 的目的是什么</a></li><li class="sidebar-sub-header"><a href="/js/jsInterview2021.html#安全隐患" title="安全隐患" class="sidebar-link">安全隐患</a></li></ul></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h2> <p>每个对象都有一个原型对象,对象以其原型为模板,从原型继承方法和属性.</p> <ul><li>对象的 <code>_proto_</code> 指向其原型</li> <li>原型对象的 <code>constructor</code> 指向构造函数</li> <li>构造函数的 <code>prototype</code> 指向原型</li></ul> <p><strong>原型引用值得修改</strong> 以该原型为模板的对象都会受影响</p> <h2 id="箭头函数-和-普通函数"><a href="#箭头函数-和-普通函数" class="header-anchor">#</a> 箭头函数 和 普通函数</h2> <ol><li>写法简洁</li> <li>没有自己 this; 从<strong>上下文继承</strong> this; 在创建前就确定了</li> <li>this 指向永远不会改变</li> <li>call apply bind 无法改变 this 指向</li> <li>不能作为构造函数</li> <li>没有 arguments</li> <li>没有 prototype</li> <li>不能做 generator 函数; 不能使用 yield 关键字</li></ol> <h2 id="改变-this"><a href="#改变-this" class="header-anchor">#</a> 改变 this</h2> <p><strong>第一个参数均为 this</strong></p> <ul><li><p>call</p></li> <li><p>apply 第二个参数是一个数组</p></li></ul> <h2 id="数组遍历方法"><a href="#数组遍历方法" class="header-anchor">#</a> 数组遍历方法</h2> <ul><li>map</li> <li>forEach</li> <li>some</li> <li>filter</li> <li>reduce</li> <li>find</li> <li>findIndex 返回目标元素的索引</li></ul> <h2 id="let-const-var"><a href="#let-const-var" class="header-anchor">#</a> let const var</h2> <ul><li>let var 不用设置初始值</li> <li>var 可以重复声明 let const 不可以</li> <li>let 允许重新赋值 const 不可以</li> <li>var 有变量提升 let const 没有</li> <li>var 声明的变量 可以添加成为全局对象的属性 let const 不可以</li></ul> <h2 id="new"><a href="#new" class="header-anchor">#</a> new</h2> <ol><li>创建一个对象</li> <li>将构造函数的作用域赋给新对象（也就是将对象的**<code>_proto_</code>**属性指向构造函数的 prototype ）</li> <li>构造函数中的 this 指向该对象（也就是为这个对象添加属性和方法）</li> <li>返回该对象</li></ol> <h2 id="react-生命周期"><a href="#react-生命周期" class="header-anchor">#</a> react 生命周期</h2> <ol><li>组件挂载阶段 constructor getDerivedStateFromProps render componentDidMount</li> <li>组件更新阶段 getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate</li> <li>组件卸载阶段 componentWillUnmount</li> <li>错误处理阶段 getDerivedStateFromProps componentDidCatch</li></ol> <h2 id="废除了哪些生命周期-为什么"><a href="#废除了哪些生命周期-为什么" class="header-anchor">#</a> 废除了哪些生命周期? 为什么?</h2> <h3 id="废除"><a href="#废除" class="header-anchor">#</a> 废除</h3> <ol><li>componentWillMount
<ol><li>初始化数据可以在 constructor 中执行 异步数据可以在 componentDidMount 中获取</li> <li>在 componentWillMount 中订阅事件 在服务端不会执行 componentWillUnmount 服务端会导致内存泄漏</li></ol></li> <li>componentWillReceiveProps 初始化 render 时不执行; 接收到新的 Props 时触发; 使用<strong>getDerivedStateFromProps</strong> 替代
<ol><li>使用 this 容易写出副作用代码</li> <li>容易造成死循环</li></ol></li> <li>componentWillUpdate
<ol><li>一次更新时会被调用多次</li> <li>componentDidUpdate 一次更新中只会被调用一次</li></ol></li></ol> <h3 id="新增"><a href="#新增" class="header-anchor">#</a> 新增</h3> <ol><li>componentDidCatch</li> <li>getSnapshotBeforeUpdate 返回值作为 componentDidUpdate 第三个参数; render 之后 dom 渲染之前执行; 获取到的元素状态与 componentDidUpdte 中的一致</li> <li>getDerivedStateFromProps</li></ol> <h2 id="react-hooks-第三方库"><a href="#react-hooks-第三方库" class="header-anchor">#</a> react Hooks? 第三方库</h2> <ul><li>useState</li> <li>useEffect</li> <li>useContext</li> <li>useReducer</li></ul> <p><code>ahooks react-use use-deep-compare-effect</code></p> <h2 id="usememo-usecallback-区别"><a href="#usememo-usecallback-区别" class="header-anchor">#</a> useMemo useCallback 区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 缓存函数</span>
<span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 缓存 第一个入参执行后返回的值</span>
<span class="token comment">// 用于大数据量计算的数据缓存 密集型计算</span>
<span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在Hooks中获取上一次指定的props</span>
<span class="token keyword">const</span> <span class="token function-variable function">usePrevProps</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  React<span class="token punctuation">.</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ref<span class="token punctuation">.</span>current <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ref<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="网络请求库"><a href="#网络请求库" class="header-anchor">#</a> <a href="https://zhuanlan.zhihu.com/p/52235130" target="_blank" rel="noopener noreferrer">网络请求库<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <h3 id="axios-最好用-基于-promise-的-http-客户端-可用于浏览器和-node-js"><a href="#axios-最好用-基于-promise-的-http-客户端-可用于浏览器和-node-js" class="header-anchor">#</a> axios 最好用 基于 promise 的 http 客户端; 可用于浏览器和 node.js</h3> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>同时支持 node.js 和浏览器</li> <li>支持 Promise API</li> <li>可以配置或取消请求</li> <li>可以设置响应超时</li> <li>支持防止跨站点请求伪造（XSRF）攻击</li> <li>可以拦截未执行的请求或响应</li> <li>支持显示上传进度</li> <li>广泛用于 React 和 Vue 项目</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <p>使用起来麻烦</p> <h3 id="superagent"><a href="#superagent" class="header-anchor">#</a> superagent</h3> <h3 id="request"><a href="#request" class="header-anchor">#</a> request</h3> <p>缺点 不基于 promise</p> <h3 id="fetch-浏览器自带"><a href="#fetch-浏览器自带" class="header-anchor">#</a> fetch 浏览器自带</h3> <p><strong>优点:</strong> 灵活易用; 支持现代所有浏览器;使用 promise 避免回调地狱; 支持 React Native</p> <p><strong>缺点:</strong> 不支持服务端使用; 没有取消请求功能; 没有内置默认值，如请求模式，请求头，请求凭据等</p> <h3 id="supertest"><a href="#supertest" class="header-anchor">#</a> supertest</h3> <h2 id="any-unknown-never"><a href="#any-unknown-never" class="header-anchor">#</a> any unknown never</h2> <p>never 用于永远不可能发生的情况; 空集合</p> <p>unknown 是某些值的集合,任何值都能使用该类型 unknown; 这意味着 <code>unknown</code> 是一切类型的超级类型（supertype） <code>unknown</code> 被称为顶端类型。</p> <p>any 则彻底放弃了类型检查</p> <h2 id="工程化"><a href="#工程化" class="header-anchor">#</a> <a href="https://www.zhihu.com/question/24558375" target="_blank" rel="noopener noreferrer">工程化<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ol><li>模块化 将一个大文件拆分成相互依赖的小文件 再进行统一拼装加载, 利于多人协作</li> <li>组件化
<ol><li>文件层面对代码或资源进行拆分</li> <li>设计层面 对 UI 即用户界面的拆分</li></ol></li> <li>规范化
<ol><li>目录结构制定</li> <li>编码规范</li> <li>前后端接口规范</li> <li>文档规范</li> <li>git 分支管理</li> <li>commit 描述规范</li></ol></li> <li>自动化
<ol><li>自动化部署</li> <li>自动化测试</li></ol></li></ol> <h2 id="工具链"><a href="#工具链" class="header-anchor">#</a> 工具链</h2> <ol><li>prettier</li> <li>jest</li> <li>npm</li> <li>webpack</li></ol> <h2 id="为什么使用-mobx"><a href="#为什么使用-mobx" class="header-anchor">#</a> 为什么使用 mobx</h2> <ol><li>使用方便上手快</li> <li>使用观察者模式 自动响应 store 的变化</li> <li>可以有多 store</li></ol> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>外层函数嵌套内层函数 内层函数使用外层函数的局部变量 返回内层函数</p> <p>使用场景: 封装<code>ajax</code>; 函数防抖; 单例模式; 私有变量</p> <p><strong>作用</strong></p> <ol><li>创建私有变量</li> <li>实现块级作用域</li> <li>使某些变量一直保存在内存中</li></ol> <p><strong>缺点</strong></p> <ol><li>常驻内存 增加内存的使用量</li> <li>使用不当造成内存泄漏</li></ol> <h2 id="判断变量类型"><a href="#判断变量类型" class="header-anchor">#</a> 判断变量类型</h2> <ol><li><p><strong>typeof</strong> <code>typeof 2 &quot;number&quot;</code></p></li> <li><p><strong>instanceof</strong> <code>[]instanceof Array</code></p></li> <li><p><strong>constructor</strong> <code>[].constructor===Array</code></p></li> <li><p><strong><code>Object.prototype.toString.call()</code></strong></p></li></ol> <h2 id="浏览器资源加载顺序"><a href="#浏览器资源加载顺序" class="header-anchor">#</a> 浏览器资源加载顺序</h2> <ol><li>html css font</li> <li>js xhr</li> <li>图片 语音 视频</li> <li>预加载的资源</li></ol> <p>html &gt; css &gt; 可视化图片 &gt; js &gt; 媒体</p> <h2 id="怎么提高网页的加载速度"><a href="#怎么提高网页的加载速度" class="header-anchor">#</a> 怎么提高网页的加载速度</h2> <ol><li>减少代码大小
<ol><li>在确保功能和性能下,精简代码使用简洁的代码实现;</li> <li>压缩代码</li> <li>压缩图片</li> <li>使用 css 样式代替图片 如果可以的话</li> <li>能使用 background 不使用 img 标签</li> <li>使用图片预加载和延时加载 使用缩略图做占位符代替图片 但不影响后续页面呈现</li> <li>部分图片 可以转成 base64 转成字符串 减少 http 请求</li></ol></li> <li>优化代码结构
<ol><li>样式表放在头部 ; js 标签放在底部</li> <li>放在头部 使用 async 打断后续代码执行</li></ol></li> <li>优化网络请求
<ol><li>减少网络请求次数 使用雪碧图 合并多个 js 或 css 文件减少网络请求</li> <li>cookie 使用缓存 设置期限</li> <li>减少 cookie 大小</li> <li>使用 cdn 服务</li></ol></li></ol> <h2 id="js-怎么遍历对象"><a href="#js-怎么遍历对象" class="header-anchor">#</a> js 怎么遍历对象</h2> <ol><li>for in</li> <li><code>Object.keys()</code></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>const obj = { 0: 'a', 1: 'b', 2: 'c' };
Object.keys(obj) // 返回包含所有非symbol类型的属性列表  ['0', '1', '2']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="css-优先级"><a href="#css-优先级" class="header-anchor">#</a> css 优先级</h2> <p>内联 <code>&gt;</code> id <code>&gt;</code> class <code>=</code>属性选择器 <code>=</code> 伪类选择器 <code>&gt;</code> 标签 <code>=</code>伪类 <code>&gt;</code> 兄弟+ <code>=</code> 子选择器&gt; <code>=</code> 后代选择器 <code>=</code> <strong><code>*</code>通配符</strong></p> <p>!important 最高</p> <h2 id="css-定位-悬浮右下角"><a href="#css-定位-悬浮右下角" class="header-anchor">#</a> css 定位 悬浮右下角</h2> <p><code>position:fixed; z-index</code></p> <h2 id="jsonp-以及缺点"><a href="#jsonp-以及缺点" class="header-anchor">#</a> jsonp 以及缺点</h2> <p>jsonp 处理跨域</p> <p>json 被 js 原生支持</p> <p>用户传递一个 callback 参数给服务器 服务器返回时将 callback 参数作为函数名来包裹 json 数据 客户端制定函数处理数据</p> <p><strong>缺点</strong></p> <ol><li>只支持 get 请求</li> <li>不支持使用 <code>async:false</code> 方式设置同步</li> <li>没有错误处理</li></ol> <h2 id="ajax"><a href="#ajax" class="header-anchor">#</a> ajax</h2> <p>一种异步请求数据的 web 开发技术 在不刷新页面的情况下通过 ajax 异步请求数据实现局部更新</p> <ol><li>浏览器使用 xhr 请求数据</li> <li>浏览器去完成其他任务</li> <li>xhr 请求数据</li> <li>服务器返回数据给 xhr</li> <li>xhr 通知浏览器已获取到数据</li> <li>浏览器接收 xhr 返回的数据 渲染页面</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open(&quot;GET&quot;, &quot;/api/*&quot;, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = &quot;json&quot;;
xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
// 发送 Http 请求
xhr.send(null);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="jquery-选择器-选择页面所有的-name-hello-的-input-框-并且给所有的-input-框赋值-test"><a href="#jquery-选择器-选择页面所有的-name-hello-的-input-框-并且给所有的-input-框赋值-test" class="header-anchor">#</a> jQuery 选择器，选择页面所有的 name=hello 的 input 框，并且给所有的 input 框赋值&quot;test&quot;</h2> <p><code>$(&quot;input[name='hello']&quot;)</code> <code>.val(&quot;test&quot;)</code></p> <h2 id="虚拟-dom"><a href="#虚拟-dom" class="header-anchor">#</a> 虚拟 dom</h2> <p>一个用来描述真实 dom 的 js 对象</p> <ol><li>diff 算法 对比新老 虚拟 dom 变化 将变化更新到视图上(真实 dom); 对应到代码上就是一个 diff 函数</li> <li>跨平台 服务端渲染 ssr</li></ol> <h2 id="js-创建对象"><a href="#js-创建对象" class="header-anchor">#</a> js 创建对象</h2> <ol><li><p>字面量 将成员信息写到{}中,并赋值给一个变量 此时这个变量就是一个对象</p></li> <li><p>构造函数 new</p></li> <li><p><code>const obj=new Object()</code></p></li> <li><p>通过原型 创建对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>使用原型 将属性和方法绑定到原型上  属性和方法是共享的
	function Animal() {}

	Animal.prototype.name = 'animal';
	Animal.prototype.sayName = function() {
		alert(this.name);
	};

	var a1 = new Animal();
	var a2 = new Animal();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>class</p></li></ol> <h2 id="清除浮动"><a href="#清除浮动" class="header-anchor">#</a> 清除浮动</h2> <ol><li><p>子级最后一个元素 <code>clear:both</code></p></li> <li><p>父级 overflow: auto</p></li> <li><div class="language- line-numbers-mode"><pre class="language-text"><code>.f{zoom:1;}

.f :after {clear:both;content:'.';display:block;width: 0;height: 0;visibility:hidden;}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol> <h2 id="让一个页面元素看不见"><a href="#让一个页面元素看不见" class="header-anchor">#</a> 让一个页面元素看不见</h2> <ol><li><p><code>visibility:hidden;</code></p></li> <li><p><code>display:none;</code></p></li> <li><p><code>opacity:0;</code> 隐身</p></li> <li><p>设置盒模型属性为 0</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>.box1 {
        width: 0;
        height: 0;
        padding: 0;
        border: 0;
        margin: 0;
        overflow: hidden;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>绝对地位将元素移除屏幕 position: absolute;</p></li> <li><p>绝对定位 z-index 设置成小的负数</p></li></ol> <h2 id="react-router-原理"><a href="#react-router-原理" class="header-anchor">#</a> react router 原理</h2> <p>保持 ui 和 url 同步</p> <p>history 监听浏览器地址的变化，并解析 url 转化为 location 对象，然后 router 使用它匹配到路由，渲染对应的组件</p> <p>每个路由都有 Enter 和 Leave 钩子，用户进入或离开该路由时触发</p> <p>是一个路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。</p> <ol><li>hashHistory</li> <li>browserHistory</li> <li>createMemoryHistory</li></ol> <h2 id="盒模型"><a href="#盒模型" class="header-anchor">#</a> 盒模型</h2> <p>margin border padding content</p> <p>标准模式 IE 模型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>标准 box-sizing:conent-box; // width 包含内容区
怪异 box-sizing:border-box; // width 包含border padding 内容区
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="页面性能优化"><a href="#页面性能优化" class="header-anchor">#</a> 页面性能优化</h2> <ol><li>资源压缩 html css js 代码压缩 非核心代码异步加载 图片懒加载</li> <li>使用浏览器缓存</li> <li>使用 cdn 加速</li></ol> <h2 id="解决跨越"><a href="#解决跨越" class="header-anchor">#</a> <a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener noreferrer">解决跨越<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>1、 通过 jsonp 跨域 2、 <code>document.domain + iframe</code> 跨域 3、 <code>location.hash + iframe</code> 4、 <code>window.name + iframe</code> 跨域 5、 <code>postMessage</code> 跨域 6、 跨域资源共享（CORS） 7、 nginx 代理跨域 8、 node.js 中间件代理跨域 9、 WebSocket 协议跨域</p> <h2 id="如果你接到一个项目如何从头开始的-需求-技术选型-技术环境-依赖哪些组件"><a href="#如果你接到一个项目如何从头开始的-需求-技术选型-技术环境-依赖哪些组件" class="header-anchor">#</a> 如果你接到一个项目如何从头开始的(需求，技术选型，技术环境，依赖哪些组件)</h2> <ol><li>需求</li> <li>技术选型 大型后台系统 react 中小型 vue</li> <li>技术环境</li> <li>依赖哪些组件</li></ol> <h2 id="js-继承"><a href="#js-继承" class="header-anchor">#</a> <a href="https://segmentfault.com/a/1190000016708006" target="_blank" rel="noopener noreferrer">js 继承<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ol><li><p>原型链继承</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//父类型</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>play <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//子类型</span>
<span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setScore</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子类型的原型为父类型的一个实例对象</span>

<span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">15000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">14000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li> <li><p>构造函数继承</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 在子类型构造函数中通用call()调用父类型构造函数function Person(name, age) {  this.name = name;  this.age = age;  this.setName = function () {};}Person.prototype.setAge = function () {};function Student(name, age, price) {  Person.call(this, name, age);  /* 相当于  this.Person(name, age);  this.name = name;  this.age = age; */  this.price = price;}var s1 = new Student(&quot;Tom&quot;, 20, 15000);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>组合继承 原型链加构造函数</p></li> <li><p>class 继承 extends <strong>class 关键字只是原型的语法糖，JavaScript 继承仍然是基于原型实现的</strong>。</p></li></ol> <h2 id="js-作用域有哪些"><a href="#js-作用域有哪些" class="header-anchor">#</a> js 作用域有哪些</h2> <ol><li><p>全局作用域</p></li> <li><p>局部作用域 函数内部</p></li> <li><p>块级作用域</p></li> <li><p>词法作用域 <strong>当我们要使用声明的变量时：JS 引擎总会从最近的一个域，向外层域查找；</strong></p></li> <li><p>动态作用域 this</p> <p>动态作用域，作用域是基于调用栈的，而不是代码中的作用域嵌套；</p> <p>作用域嵌套，有词法作用域一样的特性，查找变量时，总是寻找最近的作用域；</p></li></ol> <h2 id="屏幕适配"><a href="#屏幕适配" class="header-anchor">#</a> 屏幕适配</h2> <h3 id="响应式布局"><a href="#响应式布局" class="header-anchor">#</a> 响应式布局</h3> <p>使用媒体查询</p> <ul><li>适用于简单页面</li> <li>每个分辨率 都会形成一套样式</li> <li>屏幕分辨率分区间 使用主流分辨率进行区间划分 无法做到 100% 兼容</li></ul> <h3 id="viewport-缩放"><a href="#viewport-缩放" class="header-anchor">#</a> viewport 缩放</h3> <p>对不同分辨率屏幕进行等比例缩放</p> <h3 id="rem"><a href="#rem" class="header-anchor">#</a> rem</h3> <p>在不同分辨率下动态计算出跟节点的 font-size 大小</p> <h2 id="http-三次握手-四次挥手"><a href="#http-三次握手-四次挥手" class="header-anchor">#</a> http 三次握手 四次挥手</h2> <p>TCP 的三次握手就是建立连接的过程，而四次挥手就是断开连接的过程。</p> <h2 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> http 状态码</h2> <ul><li>301 资源重定向 已被永久删除</li> <li>302 资源重定向 临时移动</li> <li>304 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li></ul> <h2 id="react-特点"><a href="#react-特点" class="header-anchor">#</a> react 特点</h2> <p>虚拟 DOM，组件化设计模式，声明式代码，单向数据流，使用 jsx 描述信息等特点</p> <h2 id="什么是组件化设计模式"><a href="#什么是组件化设计模式" class="header-anchor">#</a> 什么是组件化设计模式</h2> <p>可复用的代码可以抽成组件共同使用（UI，方法等）</p> <h2 id="什么是单向数据流"><a href="#什么是单向数据流" class="header-anchor">#</a> 什么是单向数据流</h2> <p>数据主要从父节点传到子节点（通过 props）,如果父级的某个 props 改变了，React 会重新渲染所有子节点（像瀑布的水一样，从上往下流，这个水就是组件的数据流。）</p> <h2 id="react-的优缺点"><a href="#react-的优缺点" class="header-anchor">#</a> react 的优缺点</h2> <p>优点：</p> <ul><li>提高了应用性能和开发效率</li> <li>使用 JSX,代码可读性好</li> <li>react 的 componentWillUnmount 生命周期，能够清除相关所有事件，避免内存泄露</li> <li>并不直接对 DOM 进行操作，引入了一个虚拟 DOM 的概念，安插在 js 和真实 DOM 中间，性能好，速度快缺点：</li> <li>每次 state 更改，render 函数都要生成完整的虚拟 DOM. 哪怕 state 改动很小，render 函数也会完整计算一遍。如果 render 函数很复杂，这个过程就白白浪费了很多计算资源</li></ul> <h2 id="vue-与-react-两个框架的区别对比"><a href="#vue-与-react-两个框架的区别对比" class="header-anchor">#</a> VUE 与 React 两个框架的区别对比</h2> <p>相似之处：</p> <ul><li><p>用于创建 UI 的 js 库</p></li> <li><p>使用起来轻快便捷</p></li> <li><p>都用了虚拟 DOM</p></li> <li><p>都是基于组件的架构不同点：</p></li> <li><p>vue 使用的 html 模板；react 使用的是 js</p></li> <li><p>vue 有双向绑定语法</p></li> <li><p>vue 增加了语法糖 computed 和 watch 等，react 需要自己写逻辑来实现</p></li> <li><p>react 用了 jsx 语法</p></li> <li><p>react 整体思路是编程式，推荐组件化，数据不变，单向数据流；vue 数据可变，双向绑定，声明式的写法</p></li></ul> <h2 id="react-的工作原理"><a href="#react-的工作原理" class="header-anchor">#</a> React 的工作原理</h2> <p>React 会创建一个虚拟的 DOM。当一个组件的状态改变时，React 首先会通过“diffing&quot;算法来标记虚拟 DOM 中的改变，第二步是调节，会用 diff 的结果来更新 DOM.</p> <h2 id="为什么虚拟-dom-会提高性能"><a href="#为什么虚拟-dom-会提高性能" class="header-anchor">#</a> 为什么虚拟 DOM 会提高性能</h2> <ul><li>虚拟 DOM 相当于在 JS 和真实 DOM 中间加了一个缓存，利用 diff 减少了没有必要的操作，从而提高性能，本质上是 JS 对象。</li> <li>虚拟 DOM 是映射真实 DOM 的 js 对象数据结构</li> <li>采用虚拟 DOM，避免直接操作真实的 DOM，提供性能</li> <li>当状态更新时，重新渲染新的虚拟 DOM，采用 diff 算法对比新旧 DOM，进行更新</li></ul> <h2 id="阻止-react-的默认行为"><a href="#阻止-react-的默认行为" class="header-anchor">#</a> 阻止 React 的默认行为</h2> <p>e.preventDefault() e 是第三方提供的一个合成事件 不可以使用 return</p> <h2 id="react-中-key-作用是什么"><a href="#react-中-key-作用是什么" class="header-anchor">#</a> React 中 key 作用是什么？</h2> <p>作用（目的）：key 是用于追踪那些列表中元素被修改，删除或者被添加的辅助标识。在 diff 算法中，key 用来判断该元素节点是被 移动过来的还是新创建元素，减少不必要的元素重复渲染。</p> <h2 id="react-中-diff-算法"><a href="#react-中-diff-算法" class="header-anchor">#</a> React 中 diff 算法</h2> <p>diff 算法的原理</p> <ul><li>将树形结构按照层级分解，只比较同级元素</li> <li>给列表结构的每个单元添加唯一的 key 属性，方便比较</li> <li>React 只会匹配相同的 class 的 component</li> <li>合并操作，调用 component 的 setState 方法的时候，React 将其标记为 dirty,到每一轮事件循环结束，React 检查所有标记 dirty 的 component 重新渲染</li> <li>选择性子树渲染。开发人员可以重新 shouldComponentUpdate 提高 diff 的性能。</li></ul> <p>diff 三种策略</p> <ul><li>tree diff:DOM 节点跨层级的移动操作特别少，可以忽略不计。</li> <li>component diff:拥有相同类的两个组件生成相似的数据结构；拥有不同类的两个组件生成不同的树形结构</li> <li>element diff:对于同一层级的一组子节点，通过唯一 id 区分</li></ul> <h2 id="调用-setstate-之后发生了什么"><a href="#调用-setstate-之后发生了什么" class="header-anchor">#</a> 调用 setState 之后发生了什么</h2> <p>setState 会进行状态更新</p> <p>将传入的参数对象与组件当前状态合并，然后触发所谓的调和过程，经过调和过程，根据新的 state,React 元素会重新构建虚拟 DOM，进行 diff 算法对比新旧虚拟 DOM 树的区别，进行视图更新，而不是全部渲染。</p> <p>setState 采用的任务队列机制，不会马上执行，而是加入队列，在下次事件循环是一次性执行</p> <h2 id="为什么建议传递给-setstate-的参数是一个-callback-回调函数-而不是一个对象"><a href="#为什么建议传递给-setstate-的参数是一个-callback-回调函数-而不是一个对象" class="header-anchor">#</a> 为什么建议传递给 setState 的参数是一个 callback（回调函数）而不是一个对象</h2> <p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖他们的值去计算下一个 state</p> <h2 id="setstate-第二个参数的作用"><a href="#setstate-第二个参数的作用" class="header-anchor">#</a> setState 第二个参数的作用</h2> <p>该函数会在 setState 函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成</p> <h2 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="header-anchor">#</a> (在构造函数中)调用 super(props) 的目的是什么</h2> <p>在 super() 被调用之前，子类是不能使用 this 的，在 ES5 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props</p> <h2 id="安全隐患"><a href="#安全隐患" class="header-anchor">#</a> 安全隐患</h2> <ol><li>xss 脚本攻击漏洞 <strong>在文本输入或 html 标签中插入脚本进行攻击</strong> <ol><li>对一些标签进行转义</li></ol></li> <li>csrf 跨站请求伪造
<ol><li>增加 token 校验</li> <li>Referer 验证 页面来源判断</li></ol></li> <li>iframe
<ol><li>使用安全的网站进行嵌入</li> <li>iframe 添加 sandbox 属性 浏览器会对 iframe 进行严格控制</li></ol></li> <li>本地数据存储
<ol><li>清除 localStorage 数据</li> <li>cookie 过期</li> <li>本地存储数据进行加密处理</li></ol></li> <li>第三方依赖</li> <li>https 加密传输数据 使用 https</li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/18/2021, 5:17:50 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/js/string.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        字符串
      </a></span> <!----></p></div> </main> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.5730d439.js" defer></script><script src="/assets/js/2.8e0bb991.js" defer></script><script src="/assets/js/12.3ce7e4c0.js" defer></script>
  </body>
</html>